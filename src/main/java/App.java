import com.google.common.collect.Table;
import com.google.common.collect.TreeBasedTable;
import org.apache.commons.collections4.trie.PatriciaTrie;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.LineIterator;
import org.apache.commons.lang3.StringUtils;

import java.io.File;
import java.io.IOException;
import java.util.*;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class App {

    private static final int VOCABULARY_SIZE = 50000;
    private static final int MIN_OCCURRENCES = 50;

    Set<String> buildVocabulary(String wikiArticlesFilePath) throws IOException {
        return buildVocabulary(wikiArticlesFilePath, VOCABULARY_SIZE, MIN_OCCURRENCES);
    }

    private Set<String> buildVocabulary(String wikiArticlesFilePath, int vocabularySize, int minOccurrences) throws IOException {
        PatriciaTrie<Integer> vocabulary = new PatriciaTrie<>();
        try (LineIterator it = FileUtils.lineIterator(new File(wikiArticlesFilePath), "UTF-8")) {
            while (it.hasNext()) {
                String[] corpus = StringUtils.split(it.nextLine());
                addCorpus2Vocabulary(vocabulary, corpus);
            }
        }
        return filterVocabulary(vocabularySize, minOccurrences, vocabulary);
    }

    private void addCorpus2Vocabulary(PatriciaTrie<Integer> vocabulary, String[] corpus) {
        if (corpus.length > 0) {
            PatriciaTrie<Integer> wordCounts = countWords(corpus);
            for (Map.Entry<String, Integer> entry : wordCounts.entrySet()) {
                String word = entry.getKey();
                Integer occurrences = entry.getValue();
                vocabulary.put(word, vocabulary.getOrDefault(word, 0) + occurrences);
            }
        }


    }

    private Set<String> filterVocabulary(int vocabularySize, int minOccurrences, PatriciaTrie<Integer> vocabulary) {
        Set<String> vocab = new HashSet<>();
        vocabulary.values().removeIf(value -> value < minOccurrences);
        vocabulary.entrySet().stream()
                .sorted(Map.Entry.comparingByValue())
                .limit(vocabularySize)
                .forEach(entry -> vocab.add(entry.getKey()));
        return vocab;
    }

    private PatriciaTrie<Integer> countWords(String[] corpus) {
        Arrays.sort(corpus);
        PatriciaTrie<Integer> trie = new PatriciaTrie<>();
        Integer count = 0;
        String w = corpus[0];
        for (String word : corpus) {
            if (word.equals(w)) {
                count++;
            } else {
                trie.put(w, count);
                w = word;
                count = 1;
            }
        }
        return trie;
    }

    Table<String, Integer, Integer> buildTermDocumentMatrix(String wikiArticlesFilePath, Set<String> vocabulary) throws IOException {
        Table<String, Integer, Integer> termDocumentMatrix = TreeBasedTable.create();
        try (LineIterator it = FileUtils.lineIterator(new File(wikiArticlesFilePath), "UTF-8")) {
            int documentIndex = 0;
            while (it.hasNext()) {
                String[] corpus = StringUtils.split(it.nextLine());

                if (corpus.length > 0) {
                    PatriciaTrie<Integer> wordCounts = countWords(corpus);
                    wordCounts.keySet().removeIf(word -> !vocabulary.contains(word));
                    int docIndex = documentIndex;
                    wordCounts.forEach((word, occurrences) -> termDocumentMatrix.put(word, docIndex, occurrences));
                    documentIndex++;
                }


            }
        }
        return termDocumentMatrix;
    }

    Table<String, Integer, Double> reduceTermDocumentMatrix(Table<String, Integer, Integer> termDocumentMatrix, int k, double epsilon) {
        Table<String, Integer, Double> reduced = TreeBasedTable.create();
        double x = Math.sqrt(k) / epsilon;
        double oneProbability = epsilon / (2 * k);
        List<Short> randomIV = generateRandomIV(oneProbability);

        termDocumentMatrix.rowMap().forEach((word, documentOccurrenceMap) -> {
            Map<Integer, Double> randomVector = generateRandomVector(x, randomIV, k);
            randomVector.values().removeIf(value -> value.equals(0d));
            documentOccurrenceMap.forEach((documentIndex, termOccurrences) ->
                    updateReducedMatrix(reduced, word, termOccurrences, randomVector));

        });

        return reduced;
    }

    private void updateReducedMatrix(Table<String, Integer, Double> reduced, String word, Integer termOccurrences, Map<Integer, Double> randomVector) {
        randomVector.forEach((columnIndex, value) -> {
            Double oldReducedValue = reduced.row(word).getOrDefault(columnIndex, 0d);
            reduced.put(word, columnIndex, oldReducedValue + (termOccurrences * value));
        });
    }

    Map<Integer, Double> generateRandomVector(double x, List<Short> randomIV, int size) {
        Map<Integer, Double> randomVector = new HashMap<>(size);
        Random rand = new Random();
        for (int i = 0; i < size; i++) {
            randomVector.put(i, x * randomIV.get(rand.nextInt(100)));
        }

        return randomVector;
    }

    List<Short> generateRandomIV(double oneProbability) {
        List<Short> randomIV = new ArrayList<>(100); // 2 decimal precision
        int numOnes = (int) (oneProbability * 100);

        for (int i = 0; i < 100; i++) {
            randomIV.add((short) (i >= 2 * numOnes ? 0 : (i >= numOnes ? -1 : 1)));
        }

        Collections.shuffle(randomIV);
        return randomIV;
    }


}
